<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/png" href="favicon.png">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Think in Bars!</title>
  <!-- KaTeX CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" xintegrity="sha384-n8MV3yEaB+P+VeRv5sY0hVlRPzUf6T4sJmRjXWlPN8zmH+LPN5/u+WsohV3yFo" crossorigin="anonymous">
  <!-- KaTeX JS -->
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" xintegrity="sha384-pm558ppHF8wkW4M4CeQaSgSjgMzTPO7O6ftTWt7IuVqR8ObvX2CyFN5M0X+qLVu" crossorigin="anonymous"></script>
  <!-- KaTeX auto-render extension -->
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" xintegrity="sha384-+VBxd3r6XgURNyg51HnJ8vKumO/RvGFoRPfpeEHRLA" crossorigin="anonymous"></script>

  <style>
    /* Basic reset and body styling for full viewport coverage */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: 'Inter', sans-serif; /* Using Inter font */
      overflow-x: hidden; /* Prevent horizontal scrolling */
      width: 100vw;
      height: 100vh;
      max-width: 100vw;
    }
    
    /* Flex container for the entire layout (canvas + toolbar) */
    body {
      display: flex;
      flex-direction: column;
    }
    
    /* Container for the canvases, allowing it to take available space */
    #canvas-container {
      flex: 1; /* Takes up remaining vertical space */
      position: relative;
      overflow: hidden;
      width: 100vw;
      /* Fixed height calculation to prevent layout shifts */
      height: calc(100vh - 80px); /* Adjust based on toolbar height */
      max-height: calc(100vh - 80px); /* Ensure it doesn't exceed this */
      margin: 0 auto;
      background-color: white;
    }
    
    /* Individual canvas styling - absolute positioning to layer them */
    #background-canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      background-color: white;
    }
    
    #main-canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 2;
    }
    
    #drawingCanvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 3;
      pointer-events: none; /* Allows clicks to pass through when not in draw mode */
    }
    
    /* Toolbar styling - responsive and scrollable */
    .toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 24px;
      background: #eee;
      border-top: 2px solid #ccc;
      gap: 30px;
      flex-wrap: nowrap; /* Prevent wrapping for horizontal scroll */
      overflow-x: auto; /* Enable horizontal scrolling for small screens */
      height: 80px; /* Fixed height for toolbar to prevent shifts */
      flex-shrink: 0; /* Prevent toolbar from shrinking */
      -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
      scrollbar-width: none; /* Hide scrollbar for Firefox */
    }
    /* Hide scrollbar for Chrome, Safari, Opera */
    .toolbar::-webkit-scrollbar {
      display: none;
    }
    
    /* Tool button styling */
    .tool-button {
      width: 48px;
      height: 48px;
      border: none;
      background: transparent;
      cursor: pointer;
      margin: 4px;
      padding: 8px;
      min-width: 44px; /* Ensure minimum touch target size */
      min-height: 44px;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px; /* Rounded corners */
      transition: background 0.2s ease, transform 0.1s ease; /* Smooth transitions */
    }

    .tool-button:hover {
      background: rgba(0, 0, 0, 0.05);
    }

    .tool-button:active {
      transform: scale(0.95);
    }
    
    .tool-button img {
      width: 28px;
      height: 28px;
      object-fit: contain;
      vertical-align: middle;
    }
    
    /* Color button specific styling */
    .color-button {
      width: 36px;
      height: 36px;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
    }
    
    /* Active state for tool buttons */
    .tool-button.active {
      outline: 3px solid #007bff;
      border-radius: 6px;
      box-shadow: 0 0 8px rgba(0, 123, 255, 0.4);
    }
    
    /* Title banner styling */
    .title-banner {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 28px;
      font-weight: bold;
      background: #fff;
      padding: 6px 12px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      z-index: 10;
      text-align: center;
    }
    
    /* About Modal styling */
    #aboutModal, #problemGeneratorModal, #versionHistoryModal, #barModelIdeaModal {
      display: none; /* Hidden by default */
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 500px;
      max-width: 90%; /* Responsive width */
      background: white;
      padding: 24px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      border-radius: 10px;
      z-index: 999;
      font-size: 16px;
      line-height: 1.6;
      border: 1px solid #ddd;
      max-height: 80vh; /* Limit modal height */
      overflow-y: auto; /* Enable scrolling for modal content */
    }

    #aboutModal h2, #problemGeneratorModal h2, #versionHistoryModal h2, #barModelIdeaModal h2 {
      color: #333;
      margin-top: 0;
      margin-bottom: 15px;
    }

    #aboutModal ul, #versionHistoryModal ul {
      list-style-type: disc;
      margin-left: 20px;
      margin-bottom: 15px;
    }

    #aboutModal li, #versionHistoryModal li {
      margin-bottom: 5px;
    }
    
    /* Bar label styling (for dynamically created input elements) */
    .bar-label {
      color: black !important;
      background-color: rgba(255, 255, 255, 0.9) !important;
      border: 1px solid #ccc !important;
      border-radius: 4px;
      padding: 2px 5px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      max-width: 150px; /* Adjust maximum width as needed */
      overflow: hidden;
      white-space: nowrap; /* Prevent wrapping */
      text-overflow: ellipsis; /* Add ellipsis if text overflows */
      /* Make transparent by default */
      background: transparent !important;
      border: none !important;
      box-shadow: none !important;
      padding: 0 !important;
      border-radius: 0 !important;
    }

    /* Split menu styling */
    #split-menu {
      display: flex;
      flex-wrap: wrap; /* Allow buttons to wrap */
      gap: 4px;
      background: #fff;
      border: 1px solid #ccc;
      padding: 8px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }

    #split-menu button {
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 6px 10px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s ease;
    }

    #split-menu button:hover {
      background: #0056b3;
    }

    /* Problem Generator Modal specific styles */
    #problemGeneratorModal textarea {
      width: calc(100% - 20px);
      min-height: 80px;
      padding: 10px;
      margin-bottom: 15px;
      border: 1px solid #ccc;
      border-radius: 5px;
      font-family: 'Inter', sans-serif;
      font-size: 16px;
      resize: vertical;
    }

    #problemGeneratorModal button {
      padding: 10px 15px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      transition: background 0.2s ease;
      margin-left: 10px;
    }

    #problemGeneratorModal button.generate {
      background: #28a745;
      color: white;
    }
    #problemGeneratorModal button.generate:hover {
      background: #218838;
    }
    #problemGeneratorModal button.close {
      background: #6c757d;
      color: white;
    }
    #problemGeneratorModal button.close:hover {
      background: #5a6268;
    }
    /* Adjusted Q° button styling to a darker yellow tone */
    .top-left-buttons .q-button {
      background: linear-gradient(45deg, #FFC107, #FFA000); /* Amber to Dark Orange/Amber */
      color: black;
      border: 1px solid #FF8F00; /* A darker yellow border */
      font-weight: bold;
    }
    .top-left-buttons .q-button:hover {
      background: linear-gradient(45deg, #FFA000, #FF8F00); /* Darker on hover */
    }

    /* Adjusted A° button styling to a medium yellow tone */
    .top-left-buttons .solve {
      background: linear-gradient(45deg, #FFD54F, #FFEB3B); /* Medium Yellow to Light Yellow */
      color: black;
      border: 1px solid #FFC107; /* A yellow border */
      font-weight: bold;
    }
    .top-left-buttons .solve:hover {
      background: linear-gradient(45deg, #FFEB3B, #FFD54F); /* Darker on hover */
    }

    /* Adjusted M° button styling to a lighter yellow tone */
    .top-left-buttons .m-button {
      background: linear-gradient(45deg, #FFF9C4, #FFFFE0); /* Cream to Lightest Yellow */
      color: black;
      border: 1px solid #FFECB3; /* A lighter yellow border */
      font-weight: bold;
    }
    .top-left-buttons .m-button:hover {
      background: linear-gradient(45deg, #FFFFE0, #FFF9C4); /* Darker on hover */
    }

    #problemOutput {
      margin-top: 15px;
      padding: 15px;
      background-color: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 5px;
      min-height: 50px;
      white-space: normal; /* Allow wrapping */
      overflow-x: hidden; /* Prevent horizontal scrolling */
      word-wrap: break-word; /* Break long words */
      font-style: italic;
      color: #343a40;
    }
    /* Solution output is now part of solutionBubble */

    .loading-indicator {
      display: none;
      text-align: center;
      margin-top: 10px;
      font-size: 1.2em;
      color: #007bff;
    }
    .loading-indicator::after {
      content: ' .';
      animation: dots 1s steps(5, end) infinite;
    }
    @keyframes dots {
      0%, 20% { color: rgba(0,0,0,0); text-shadow: .25em 0 0 rgba(0,0,0,0), .5em 0 0 rgba(0,0,0,0); }
      40% { color: #007bff; text-shadow: .25em 0 0 rgba(0,0,0,0), .5em 0 0 rgba(0,0,0,0); }
      60% { text-shadow: .25em 0 0 #007bff, .5em 0 0 rgba(0,0,0,0); }
      80%, 100% { text-shadow: .25em 0 0 #007bff, .5em 0 0 #007bff; }
    }
    
    /* Responsive adjustments for smaller screens */
    @media (max-width: 768px) {
      .toolbar {
        padding: 10px 15px;
        gap: 15px;
      }
      .tool-button {
        width: 40px;
        height: 40px;
        min-width: 38px;
        min-height: 38px;
        padding: 6px;
      }
      .tool-button img {
        width: 24px;
        height: 24px;
      }
      .color-button {
        width: 30px;
        height: 30px;
      }
      .title-banner {
        font-size: 20px;
        padding: 4px 8px;
      }
      .title-banner div:first-child {
        font-size: 24px;
      }
      .title-banner div:last-child {
        font-size: 14px;
      }
      #aboutModal, #problemGeneratorModal, #versionHistoryModal, #barModelIdeaModal {
        padding: 15px;
        font-size: 14px;
      }
      /* Adjust button positions for smaller screens */
      .top-left-buttons, .top-right-buttons {
        top: 8px;
      }
      .top-left-buttons button, .top-right-buttons button {
        padding: 6px 10px;
        font-size: 12px;
      }
      div[style*="bottom: 90px"] { /* Copyright notice */
        bottom: 60px !important; /* Adjust if toolbar height changes */
        font-size: 10px !important;
      }
    }

    /* Persistent Problem Display Styling */
    #persistentProblemDisplay {
      position: absolute;
      top: 80px; /* Adjust based on title banner height */
      left: 50%;
      transform: translateX(-50%);
      width: 80%; /* Adjust width as needed */
      max-width: 900px; /* Max width for readability */
      background-color: #f0f8ff; /* Light blue background */
      border: 1px solid #cceeff; /* Light blue border */
      border-radius: 8px;
      padding: 12px 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      font-size: 1.1em;
      color: #333;
      text-align: center;
      z-index: 9; /* Below modals, above canvas */
      display: none; /* Hidden by default */
      line-height: 1.5;
    }

    /* Styles for new form elements in modal */
    .form-group {
        margin-bottom: 15px;
    }
    .form-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
    }
    .form-group input[type="text"], .form-group input[type="number"] {
        width: calc(100% - 22px); /* Adjust for padding and border */
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
        font-size: 16px;
        font-family: 'Inter', sans-serif;
    }
    .checkbox-group, .radio-group {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
    }
    .checkbox-group label, .radio-group label {
        display: flex;
        align-items: center;
        font-weight: normal;
    }
    .checkbox-group input[type="checkbox"], .radio-group input[type="radio"] {
        margin-right: 5px;
    }

    /* Solution Bubble Styling */
    #solutionBubble {
      display: none; /* Hidden by default */
      position: absolute;
      top: 50%;
      right: 20px; /* Position on the right side */
      transform: translateY(-50%);
      width: 300px;
      max-width: 90%; /* Responsive width */
      background-color: #e6f7ff; /* Lighter blue background */
      border: 1px solid #91d5ff; /* Light blue border */
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      z-index: 998; /* Below modals, above canvas */
      flex-direction: column; /* For vertical layout of content and buttons */
      gap: 10px;
    }
    #solutionBubble h3 {
        margin-top: 0;
        margin-bottom: 10px;
        color: #0056b3;
    }
    #solutionContent {
        min-height: 80px;
        overflow-y: auto;
        max-height: 200px; /* Limit height and allow scrolling */
        font-size: 0.95em;
        line-height: 1.8; /* Increased line height for better spacing */
        color: #333;
    }
    #solutionContent p { /* Add margin to paragraphs within solution content */
        margin-bottom: 10px;
    }
    #solutionBubble button {
        padding: 8px 12px;
        background: #007bff;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: background 0.2s ease;
    }
    #solutionBubble button:hover {
        background: #0056b3;
    }
    #solutionBubble .close-button {
        position: absolute;
        top: 8px;
        right: 8px;
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        color: #666;
    }
    #solutionBubble .close-button:hover {
        color: #333;
    }

    /* Bar Model Idea Modal specific styles */
    #barModelIdeaModal {
      top: calc(50% + 150px); /* Position below solution bubble, adjust as needed */
      max-height: 30vh; /* Make it shorter */
    }
    #barModelIdeaModal #barModelIdeaContent {
        margin-top: 15px;
        padding: 15px;
        background-color: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 5px;
        min-height: 50px;
        white-space: normal;
        overflow-x: hidden;
        word-wrap: break-word;
        font-style: italic;
        color: #343a40;
        overflow-y: auto; /* Enable scrolling for content */
        max-height: 150px; /* Limit height */
        line-height: 1.8; /* Increased line height for better spacing */
    }
    #barModelIdeaModal #barModelIdeaContent p { /* Add margin to paragraphs within idea content */
        margin-bottom: 10px;
    }

    /* Floating bar tools styling */
    #floating-bar-tools {
      position: absolute;
      display: none; /* Hidden by default */
      z-index: 100;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      flex-wrap: wrap;
      gap: 4px;
    }
    #floating-bar-tools .tool-button {
      width: 40px; /* Smaller buttons for floating menu */
      height: 40px;
      padding: 6px;
    }
    #floating-bar-tools .tool-button img {
      width: 24px;
      height: 24px;
    }
    #floating-bar-tools .tool-button span {
      font-size: 16px; /* Smaller font for floating menu */
    }


    @media (max-width: 768px) {
        #solutionBubble, #barModelIdeaModal {
            width: calc(100% - 40px); /* Adjust width for small screens */
            right: 20px;
            left: 20px;
            transform: translateY(-50%);
        }
        #barModelIdeaModal {
            top: calc(50% + 100px); /* Adjust for smaller screens */
        }
        #floating-bar-tools {
          padding: 6px;
          gap: 2px;
        }
        #floating-bar-tools .tool-button {
          width: 36px;
          height: 36px;
          padding: 4px;
        }
        #floating-bar-tools .tool-button img {
          width: 20px;
          height: 20px;
        }
        #floating-bar-tools .tool-button span {
          font-size: 14px;
        }
    }
  </style>
</head>
<body>
  <!-- Top Left Buttons -->
  <div class="top-left-buttons" style="position: absolute; top: 12px; left: 12px; z-index: 99; display: flex; gap: 8px;">
    <!-- About Button -->
    <button onclick="window.toggleAbout()" title="About"
      style="padding: 8px 12px; font-size: 14px; /* Adjusted padding */
             background: #007bff; color: white; border: none; border-radius: 6px; cursor: pointer;
             box-shadow: 0 2px 4px rgba(0,0,0,0.2); transition: background 0.2s ease, transform 0.1s ease;">
      About
    </button>

    <!-- Version Functions Button -->
    <button onclick="window.toggleVersionHistory()" title="View Version Features"
      style="padding: 8px 12px; font-size: 14px;
             background: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer;
             box-shadow: 0 2px 4px rgba(0,0,0,0.2); transition: background 0.2s ease, transform 0.1s ease;">
      Versions
    </button>

    <!-- ✨ Generate Problem Button (Q°) -->
    <button onclick="window.toggleProblemGenerator()" class="tool-button q-button" title="Generate a Word Problem with AI"
            style="padding: 8px 14px; font-size: 14px; white-space: nowrap; /* Ensure single line */
                   box-shadow: 0 2px 4px rgba(0,0,0,0.2); border-radius: 6px; cursor: pointer; transition: background 0.2s ease, transform 0.1s ease;">
      Q°
    </button>

    <!-- 💡 AI Solve Button (A°) -->
    <button onclick="window.solveProblem()" class="tool-button solve" title="Get AI Solution/Tips for the current problem"
            style="padding: 8px 14px; font-size: 14px; white-space: nowrap; /* Ensure single line */
                   box-shadow: 0 2px 4px rgba(0,0,0,0.2); border-radius: 6px; cursor: pointer; transition: background 0.2s ease, transform 0.1s ease;">
      A°
    </button>

    <!-- ✨ Bar Model Idea Button (M°) -->
    <button onclick="window.generateBarModelIdea()" class="tool-button m-button" title="Get AI Bar Model Idea"
            style="padding: 8px 14px; font-size: 14px; white-space: nowrap; /* Ensure single line */
                   box-shadow: 0 2px 4px rgba(0,0,0,0.2); border-radius: 6px; cursor: pointer; transition: background 0.2s ease, transform 0.1s ease;">
      M°
    </button>
  </div>

  <!-- Title Banner -->
  <div class="title-banner">
    <div style="font-size:32px; font-weight:bold;">Think in Bars!</div>
    <div style="font-size:18px; font-weight:normal; margin-top:4px;">A Structured Way of Problem Solving</div>
  </div>

  <!-- Persistent Problem Display -->
  <div id="persistentProblemDisplay"></div>

  <!-- Top Right Buttons -->
  <div class="top-right-buttons" style="position: absolute; top: 12px; right: 12px; z-index: 99; display: flex; gap: 8px;">
    <!-- Export as Image Button -->
    <button onclick="window.exportCanvas()" title="Export as Image (Screenshot)"
      style="padding: 8px 12px; font-size: 14px;
             background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer;
             box-shadow: 0 2px 4px rgba(0,0,0,0.2); transition: background 0.2s ease, transform 0.1s ease;">
      Export Image
    </button>

    <!-- Clear All Button -->
    <button onclick="window.clearAll()" title="Clear All" 
      style="padding: 8px 12px; font-size: 14px;
             background: #dc3545; color: white; border: none; border-radius: 6px; cursor: pointer;
             box-shadow: 0 2px 4px rgba(0,0,0,0.2); transition: background 0.2s ease, transform 0.1s ease;">
      Clear All
    </button>
  </div>

  <!-- Canvas Container for layering drawing elements -->
  <div id="canvas-container">
    <canvas id="background-canvas"></canvas>
    <canvas id="main-canvas"></canvas>
    <canvas id="drawingCanvas"></canvas>
  </div>
  
  <!-- Floating Bar Tools (appears when a bar is selected) -->
  <div id="floating-bar-tools">
    <button onclick="window.addLabel('text')" class="tool-button" title="Label Text">
      <span style="font-size: 20px;">ABC</span>
    </button>
    <button onclick="window.addLabel('num')" class="tool-button" title="Label Number">
      <span style="font-size: 20px;">123</span>
    </button>
    <button onclick="window.toggleArrow()" class="tool-button" title="Toggle Arrow">
      <img src="https://img.icons8.com/ios-glyphs/30/resize-diagonal.png" alt="Arrow Icon"/>
    </button>
    <button onclick="window.deleteSelectedElement()" class="tool-button" title="Delete Bar">
      <img src="https://img.icons8.com/ios-glyphs/30/trash--v1.png" alt="Delete Icon"/>
    </button>
    <button onclick="window.splitBar()" class="tool-button" title="Split Bar">
      <img src="https://img.icons8.com/ios-glyphs/30/divide.png" alt="Split Icon"/>
    </button>
  </div>

  <!-- Toolbar for controls -->
  <div class="toolbar" id="toolbar">
    <!-- Drawing Tools -->
    <div style="display:flex;align-items:center;gap:8px;">
      <img src="https://img.icons8.com/ios-glyphs/30/pencil-tip.png" title="Pen Size" alt="Pen Icon" style="width: 28px; height: 28px;">
      <input type="range" min="1" max="10" value="5" oninput="penSize=this.value">
      <button onclick="window.toggleDrawMode(this, 'black')" class="tool-button color-button" style="background:black" title="Black Pen"></button>
      <button onclick="window.toggleDrawMode(this, 'red')" class="tool-button color-button" style="background:red" title="Red Pen"></button>
      <button onclick="window.toggleDrawMode(this, 'blue')" class="tool-button color-button" style="background:blue" title="Blue Pen"></button>
      <button onclick="window.toggleDrawMode(this, 'purple')" class="tool-button color-button" style="background:purple" title="Purple Pen"></button>
      <button onclick="window.toggleDrawMode(this, 'orange')" class="tool-button color-button" style="background:orange" title="Orange Pen"></button>
      <button onclick="window.toggleDrawMode(this, 'green')" class="tool-button color-button" style="background:green" title="Green Pen"></button>
      <button onclick="window.undoDraw()" class="tool-button" title="Undo Drawing">
        <img src="https://img.icons8.com/ios-glyphs/30/undo.png" alt="Undo Icon"/>
      </button>
      <button onclick="window.redoDraw()" class="tool-button" title="Redo Drawing">
        <img src="https://img.icons8.com/ios-glyphs/30/redo.png" alt="Redo Icon"/>
      </button>
    </div>

    <!-- Bar Color/Type Selection (for adding new bars) -->
    <div style="display:flex;align-items:center;gap:6px;">
      <button onclick="window.startBarPlacement('white', true)" class="tool-button color-button" style="background:white; border: 2px dashed #999;" title="Dashed White Bar"></button>
      <button onclick="window.startBarPlacement('black', true)" class="tool-button color-button" style="background:black; border: 2px dashed #999;" title="Dashed Black Bar"></button>
      <button onclick="window.startBarPlacement('#f8bbd0')" class="tool-button color-button" style="background:#f8bbd0" title="Pink Bar"></button>
      <button onclick="window.startBarPlacement('#fff9c4')" class="tool-button color-button" style="background:#fff9c4" title="Yellow Bar"></button>
      <button onclick="window.startBarPlacement('#b3e5fc')" class="tool-button color-button" style="background:#b3e5fc" title="Blue Bar"></button>
      <button onclick="window.startBarPlacement('#c8e6c9')" class="tool-button color-button" style="background:#c8e6c9" title="Green Bar"></button>

      <!-- Bar Undo/Redo -->
      <button onclick="window.undoBar()" class="tool-button" title="Undo Bar Action">
        <img src="https://img.icons8.com/ios-glyphs/30/undo.png" alt="Undo Icon"/>
      </button>
      <button onclick="window.redoBar()" class="tool-button" title="Redo Bar Action">
        <img src="https://img.icons8.com/ios-glyphs/30/redo.png" alt="Redo Icon"/>
      </button>
    </div>
  </div>

  <!-- About Modal (hidden by default) -->
  <div id="aboutModal">
    <h2 style="margin-top:0;">📘 About This Tool</h2>
    <p><strong>Think in Bars!</strong> is a visual teaching aid designed to support pupils in solving word problems more effectively.</p>
    <p>It aims to:</p>
    <ul>
      <li>Help pupils <strong>understand and solve</strong> problems using <strong>bar models</strong></li>
      <li>Guide them to <strong>visualize mathematical relationships</strong> clearly</li>
      <li>Support teachers in <strong>explaining problem-solving strategies</strong> more effectively</li>
    </ul>
    <p>"Think in Bars!" was created based on real classroom needs, especially for pupils who struggle to process word problems abstractly. By turning numbers into visuals, pupils can truly <em>see the math</em> behind the words.</p>
    <p>This tool was developed by <strong>Mr. Hui Kar Loong</strong><br>
    (<em>Guru Cemerlang Matematik Sekolah Rendah</em>)<br>
    with the assistance of <strong>ChatGPT</strong> and **Gemini** by Google.</p>
    
    <div style="text-align:right; margin-top:16px;">
      <button onclick="window.toggleAbout()" style="padding: 6px 12px; background: #dc3545; color: white;
                   border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s ease;">Close</button>
    </div>
  </div>

  <!-- Version History Modal (hidden by default) -->
  <div id="versionHistoryModal">
    <h2 style="margin-top:0;">🚀 Version Features</h2>
    
    <h3>Core Features</h3>
    <ul>
      <li><strong>Bar Model Creation & Customization:</strong> Create and manipulate solid or dashed bar models, with dashed lines representing unknown or removed quantities.</li>
      <li><strong>Bar Model Manipulation:</strong> Easily resize and reposition bar models; split existing bar models into multiple equal segments; add draggable text and numerical labels directly on bar models for clear annotation; add directional arrows to bar models to indicate quantities or relationships.</li>
      <li><strong>Adjustable Grid:</strong> Customize the background grid size for precise alignment.</li>
      <li><strong>Freehand Drawing:</strong> Use a multi-color pen tool for annotations, including undo/redo functionality.</li>
    </ul>

    <h3>Enhancements</h3>
    <ul>
      <li><strong>Export Canvas:</strong> Save your bar model as an image (PNG).</li>
      <li><strong>Persistent Problem Display:</strong> Generated problems remain visible below the title for easy reference.</li>
      <li><strong>Enhanced Responsiveness:</strong> Improved layout and usability across various screen sizes (mobile, tablet, desktop).</li>
      <li><strong>Keyboard Shortcuts:</strong> Quick access to common operations like undo/redo, delete, toggle arrow, add bar, and clear all.</li>
    </ul>

    <h3>AI-Powered Features</h3>
    <ul>
      <li><strong>AI-Powered Problem Generator (Q°):</strong> Generate unique word problems based on specified number types (whole numbers, fractions, decimals, percentages), ranges, operations, themes, and keywords. Fractions are rendered using LaTeX.</li>
      <li><strong>AI-Powered Solution Provider (A°):</strong> Provides concise, step-by-step solutions or tips for the current problem in an easy-to-understand carousel format, with bold subtitles and LaTeX math rendering.</li>
      <li><strong>AI-Powered Bar Model Idea (M°):</strong> Generates a text description of how to represent the current problem using bar models.</li>
    </ul>

    <div style="text-align:right; margin-top:16px;">
      <button onclick="window.toggleVersionHistory()" style="padding: 6px 12px; background: #6c757d; color: white;
                   border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s ease;">Close</button>
    </div>
  </div>

  <!-- Problem Generator Modal -->
  <div id="problemGeneratorModal">
    <h2>✨ Generate a Word Problem</h2>
    
    <div class="form-group">
        <label>Number Type:</label>
        <div class="checkbox-group">
            <label><input type="checkbox" name="numberType" value="whole"> Whole Numbers</label>
            <label><input type="checkbox" name="numberType" value="fractions"> Fractions</label>
            <label><input type="checkbox" name="numberType" value="decimals"> Decimals</label>
            <label><input type="checkbox" name="numberType" value="percentage"> Percentage</label>
        </div>
    </div>

    <div class="form-group">
        <label for="minNumberRange">Minimum Value:</label>
        <input type="number" id="minNumberRange" value="1" min="0">
    </div>
    <div class="form-group">
        <label for="maxNumberRange">Maximum Value:</label>
        <input type="number" id="maxNumberRange" value="100" min="0">
    </div>

    <div class="form-group">
        <label>Operations:</label>
        <div class="checkbox-group">
            <label><input type="checkbox" name="operation" value="addition" checked> Addition (+)</label>
            <label><input type="checkbox" name="operation" value="subtraction"> Subtraction (-)</label>
            <label><input type="checkbox" name="operation" value="multiplication"> Multiplication (x)</label>
            <label><input type="checkbox" name="operation" value="division"> Division (÷)</label>
        </div>
    </div>

    <div class="form-group">
        <label>Bar Model Type:</label>
        <div class="checkbox-group">
            <label><input type="checkbox" name="barModelType" value="comparison"> Comparison</label>
            <label><input type="checkbox" name="barModelType" value="equal parts"> Equal Parts</label>
        </div>
    </div>

    <div class="form-group">
        <label>Theme:</label>
        <div class="radio-group">
            <label><input type="radio" name="problemTheme" value="any" checked> Any</label>
            <label><input type="radio" name="problemTheme" value="personal"> Personal</label>
            <label><input type="radio" name="problemTheme" value="work"> Work</label>
            <label><input type="radio" name="problemTheme" value="family"> Family</label>
        </div>
    </div>

    <div class="form-group">
        <label>Language:</label>
        <div class="radio-group">
            <label><input type="radio" name="problemLanguage" value="English" checked> English</label>
            <label><input type="radio" name="problemLanguage" value="Malay"> Malay</label>
            <label><input type="radio" name="problemLanguage" value="Chinese"> Chinese</label>
        </div>
    </div>

    <div class="form-group">
        <label for="problemKeywords">Keywords/Topic (optional):</label>
        <textarea id="problemKeywords" placeholder="e.g., 'total number of items', 'difference in height'"></textarea>
    </div>

    <div style="text-align:right;">
      <button class="generate" onclick="window.generateProblem()">✨ Generate</button>
      <button class="close" onclick="window.toggleProblemGenerator()">Close</button>
    </div>
    <div id="loadingIndicator" class="loading-indicator">Generating problem</div>
    <div id="problemOutput">Your generated problem will appear here.</div>
    <!-- Solution output is now handled by solutionBubble -->
  </div>

  <!-- Solution Bubble (hidden by default) -->
  <div id="solutionBubble">
      <h3>Solution Tips</h3>
      <div id="solutionContent"></div>
      <div style="display: flex; justify-content: space-between; margin-top: 10px;">
          <button id="prevStepBtn" onclick="window.showPreviousStep()">Previous</button>
          <button id="nextStepBtn" onclick="window.showNextStep()">Next</button>
      </div>
      <button class="close-button" onclick="window.closeSolutionBubble()">&times;</button>
  </div>

  <!-- Bar Model Idea Modal (hidden by default) -->
  <div id="barModelIdeaModal">
    <h2>✨ Bar Model Idea</h2>
    <div id="barModelIdeaContent"></div>
    <div id="barModelIdeaLoading" class="loading-indicator">Generating idea</div>
    <div style="text-align:right; margin-top:16px;">
      <button onclick="window.closeBarModelIdeaModal()" class="close-button"
              style="background: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer; padding: 6px 12px;">Close</button>
    </div>
  </div>

  <!-- Copyright Notice -->
  <div style="position: fixed; bottom: 90px; right: 12px; font-size: 12px; color: #777; z-index: 50;">
    © 2025 Hui Kar Loong. All rights reserved.
  </div>

  <script>
    // Get references to the canvas elements and their 2D rendering contexts
    const bgCanvas = document.getElementById('background-canvas');
    const bgCtx = bgCanvas.getContext('2d');
    const canvas = document.getElementById('main-canvas');
    const ctx = canvas.getContext('2d');
    const drawingCanvas = document.getElementById('drawingCanvas');
    const drawingCtx = drawingCanvas.getContext('2d');
    const persistentProblemDisplay = document.getElementById('persistentProblemDisplay');
    
    // Fixed unit for bar sizing and positioning, replacing the old 'gridSize' concept
    const gridSize = 80; // Fixed grid size
    
    // Application state variables
    let bars = []; // Array to store bar objects
    let selectedBar = null; // Currently selected bar for manipulation
    let penSize = 2; // Size of the drawing pen
    let penColor = 'black'; // Color of the drawing pen
    let isDrawing = false; // Flag for mouse drawing
    let isTouchDrawing = false; // Flag for touch drawing
    let currentMode = 'select'; // Current interaction mode ('select' or 'draw')
    let isDragging = false; // Flag for dragging a bar
    let isResizing = false; // Flag for resizing a bar
    let dragOffsetX = 0, dragOffsetY = 0; // Offsets for dragging
    
    // Undo/Redo stacks for drawing and bar manipulations
    let undoStack = []; // Stores canvas ImageData for drawing undo
    let redoStack = []; // Stores canvas ImageData for drawing redo
    let barUndoStack = []; // Stores deep copies of the bars array for bar undo
    let barRedoStack = []; // Stores deep copies of the bars array for bar redo
    
    let drawingImage = null; // Stores the current drawing canvas image data
    let penMode = false; // Flag to indicate if pen mode is active

    let barPlacementMode = false; // New: Flag for placing a bar
    let barColorToPlace = '';    // New: Stores color of bar to be placed
    let barDashedToPlace = false; // New: Stores dashed property of bar to be placed

    // Stores the language of the last generated problem
    let lastProblemLanguage = 'English'; 

    // Solution carousel state
    let solutionSteps = [];
    let currentStepIndex = 0;

    // Keyboard shortcuts mapping (simplified)
    const KEYBOARD_SHORTCUTS = {
      'KeyZ': { ctrlKey: true, func: window.undoBar, description: 'Undo Bar Action (Ctrl+Z)' },
      'KeyY': { ctrlKey: true, func: window.redoBar, description: 'Redo Bar Action (Ctrl+Y)' },
      'Delete': { func: window.deleteSelectedElement, description: 'Delete Selected Bar/Textbox' },
      'Backspace': { func: window.deleteSelectedElement, description: 'Delete Selected Bar/Textbox' },
      'KeyA': { func: window.toggleArrow, description: 'Toggle Arrow' },
      'KeyD': { func: window.toggleDrawMode, args: [null, penColor], description: 'Toggle Draw Mode' },
      'KeyB': { func: window.startBarPlacement, args: ['#b3e5fc'], description: 'Start placing Blue Bar' }, // Updated shortcut
      'KeyC': { func: window.clearAll, description: 'Clear All' },
    };

    /**
     * Renders LaTeX math in a given HTML element.
     * Uses KaTeX auto-render.
     * @param {HTMLElement} element - The HTML element to render math in.
     */
    function renderMathInGivenElement(element) {
        if (typeof renderMathInElement === 'function') {
            renderMathInElement(element, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false},
                ],
                throwOnError: false
            });
        }
    }

    /**
     * Resizes all canvases to fit the window and redraws content.
     * Captures current drawing before resizing to preserve it.
     */
    window.resizeCanvas = function() {
      // Save current drawing before resizing
      if (drawingCanvas.width > 0 && drawingCanvas.height > 0) {
        drawingImage = drawingCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height);
      }
      
      // Calculate new dimensions based on window size and toolbar height
      const width = window.innerWidth;
      const height = window.innerHeight - document.getElementById('toolbar').offsetHeight; // Dynamically get toolbar height
      
      // Set new dimensions for all canvases
      bgCanvas.width = canvas.width = drawingCanvas.width = width;
      bgCanvas.height = canvas.height = drawingCanvas.height = height;
      
      // Redraw background (now just a white fill) and all bars
      drawBackground();
      drawAll();
      
      // Restore the saved drawing onto the resized drawing canvas
      if (drawingImage) {
        drawingCtx.putImageData(drawingImage, 0, 0);
      }

      // Update positions of HTML labels
      updateLabels();
      positionFloatingBarTools(); // Reposition floating tools on resize
    }

    /**
     * Draws the background grid on the background canvas.
     */
    function drawBackground() {
      bgCtx.fillStyle = 'white';
      bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
      
      // Draw fine grid lines (1/10th of gridSize)
      bgCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
      bgCtx.lineWidth = 1;
      for (let x = 0; x <= bgCanvas.width; x += gridSize / 10) {
        bgCtx.beginPath();
        bgCtx.moveTo(x, 0);
        bgCtx.lineTo(x, bgCanvas.height);
        bgCtx.stroke();
      }
      for (let y = 0; y <= bgCanvas.height; y += gridSize / 10) {
        bgCtx.beginPath();
        bgCtx.moveTo(0, y);
        bgCtx.lineTo(bgCanvas.width, y);
        bgCtx.stroke();
      }
      
      // Draw major grid lines (gridSize)
      bgCtx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
      for (let x = 0; x <= bgCanvas.width; x += gridSize) {
        bgCtx.beginPath();
        bgCtx.moveTo(x, 0);
        bgCtx.lineTo(x, bgCanvas.height);
        bgCtx.stroke();
      }
      for (let y = 0; y <= bgCanvas.height; y += gridSize) {
        bgCtx.beginPath();
        bgCtx.moveTo(0, y);
        bgCtx.lineTo(y, bgCanvas.height);
        bgCtx.stroke();
      }
    }

    /**
     * Draws all bars onto the main canvas.
     */
    function drawAll() {
      ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear main canvas
      
      for (const bar of bars) {
        // Calculate bar dimensions based on ratios and gridSize
        const bx = bar.xRatio * gridSize;
        const by = bar.yRatio * gridSize;
        const bw = bar.widthRatio * gridSize;
        const bh = bar.heightRatio * gridSize;

        // Draw the bar rectangle
        ctx.fillStyle = bar.color;
        ctx.fillRect(bx, by, bw, bh);

        // Apply dashed border if specified
        if (bar.dashed) ctx.setLineDash([6, 4]);
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1.5;
        ctx.strokeRect(bx, by, bw, bh);
        ctx.setLineDash([]); // Reset line dash

        // Draw resize handle (small black square on the right edge)
        ctx.fillStyle = "#000";
        ctx.fillRect(bx + bw - 6, by + bh / 2 - 6, 12, 12);

        // Draw arrow if enabled for the bar
        if (bar.arrow) {
          // Position arrow 20px above the bar
          const y = by - 20; 
          ctx.strokeStyle = bar.dashed ? 'red' : '#000'; // Red arrow for dashed bars
          ctx.lineWidth = 2; // Thicker arrow line

          // Draw main arrow line
          ctx.beginPath();  
          ctx.moveTo(bx, y);  
          ctx.lineTo(bx + bw, y);  
          ctx.stroke();

          // Draw arrowheads
          ctx.fillStyle = ctx.strokeStyle;
          ctx.beginPath();  
          ctx.moveTo(bx + 8, y - 5);  
          ctx.lineTo(bx, y);  
          ctx.lineTo(bx + 8, y + 5);  
          ctx.fill();
          ctx.beginPath();  
          ctx.moveTo(bx + bw - 8, y - 5);  
          ctx.lineTo(bx + bw, y);  
          ctx.lineTo(bx + bw - 8, y + 5);  
          ctx.fill();
          ctx.lineWidth = 1.5; // Reset line width
        }

        // Draw split lines if bar is split
        if (bar.split > 1) {
          const w = bw / bar.split; // Width of each split segment
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.lineWidth = 1;
          for (let i = 1; i < bar.split; i++) {
            const x = bx + i * w;
            ctx.beginPath();
            ctx.setLineDash([4, 2]); // Dashed split lines
            ctx.moveTo(x, by);
            ctx.lineTo(x, by + bh);
            ctx.stroke();
            ctx.setLineDash([]); // Reset line dash
          }
        }
        
        // Draw selection outline if this bar is selected
        if (bar === selectedBar) {
          ctx.strokeStyle = '#007bff'; // Blue outline for selection
          ctx.lineWidth = 3;
          ctx.strokeRect(bx, by, bw, bh);
        }
      }
    }

    /**
     * Initiates the bar placement mode.
     * @param {string} color - The fill color of the bar.
     * @param {boolean} [dashed=false] - Whether the bar should have a dashed border.
     */
    window.startBarPlacement = function(color, dashed = false) {
      barPlacementMode = true;
      barColorToPlace = color;
      barDashedToPlace = dashed;
      // Optionally, provide visual feedback to the user that they are in placement mode
      canvas.style.cursor = 'crosshair'; 
      // Deselect any active bar tool buttons
      document.querySelectorAll('.tool-button.color-button').forEach(b => b.classList.remove('active'));
      // Hide floating bar tools when in placement mode
      document.getElementById('floating-bar-tools').style.display = 'none';
      selectedBar = null; // Deselect any bar
      drawAll(); // Redraw to remove selection outline
    }

    /**
     * Adds a text or number label to the selected bar.
     * If a label of the same type already exists, it removes it.
     * @param {string} type - 'text' for a text label, 'num' for a number label.
     */
    window.addLabel = function(type) {
      if (!selectedBar) return; // No bar selected, do nothing

      // Save current state for undo
      barUndoStack.push(JSON.parse(JSON.stringify({ bars: getSerializableBarsState() })));
      barRedoStack = []; // Clear redo stack on new action

      // Initialize labels object if it doesn't exist
      if (!selectedBar.labels) selectedBar.labels = {};

      // If label of this type already exists, remove it and return
      if (selectedBar.labels[type]) {
        selectedBar.labels[type].element.remove(); // Remove DOM element
        delete selectedBar.labels[type];
        drawAll(); // Redraw to update visual state if necessary (e.g., arrow)
        return;
      }

      // Create new input element for the label
      const label = document.createElement('input');
      label.type = 'text';
      label.value = type === 'text' ? 'Label' : '0'; // Default value
      label.dataset.type = type; // Store type for later reference
      label.classList.add('bar-label'); // Add class for styling

      // Base styles for the label (initially transparent/invisible when not editing)
      label.style.position = 'absolute';
      label.style.fontSize = '20px';
      label.style.zIndex = '100';
      label.style.cursor = 'pointer';
      label.style.width = 'auto'; // Allow width to adjust
      label.style.minWidth = '40px'; // Adjusted minimum width
      label.style.textAlign = type === 'num' ? 'center' : 'left'; // Center numbers
      label.style.outline = 'none'; // Remove focus outline

      // Position the label relative to the selected bar
      const barX = selectedBar.xRatio * gridSize;
      const barY = selectedBar.yRatio * gridSize;
      const barWidth = selectedBar.widthRatio * gridSize;
      
      let initialLabelLeft, initialLabelTop;

      if (type === 'text') {
        initialLabelLeft = barX - 70; // Position text label to the left of the bar
        initialLabelTop = barY + 5;
        label.style.left = `${initialLabelLeft}px`;
        label.style.top = `${initialLabelTop}px`;
        selectedBar.labels[type] = {
            element: label, // Store reference to the DOM element
            offsetX: initialLabelLeft - barX, // Fixed offset for text
            offsetY: initialLabelTop - barY, // Fixed offset for text
            value: label.value
        };
      } else { // type === 'num'
        initialLabelTop = barY - 45; // Adjusted: 45px above the bar
        label.style.top = `${initialLabelTop}px`;
        // Initial left will be set by the input listener based on content width
        selectedBar.labels[type] = {
            element: label,
            offsetY: initialLabelTop - barY, // Fixed Y offset for num
            value: label.value
            // offsetX for num labels is dynamic, calculated in input listener
        };
      }

      // Event listener to show editing UI when focused
      label.addEventListener('focus', function() {
        this.style.background = '#fff';
        this.style.border = '1px solid #888'; 
        this.style.boxShadow = '0 0 2px rgba(0,0,0,0.2)';
        this.style.padding = '1px 4px';
        this.style.borderRadius = '3px';
        this.style.whiteSpace = 'normal'; /* Allow wrapping when focused */
        this.style.textOverflow = 'clip'; /* Show full text when focused */
      });

      // Event listener to hide editing UI when blurred
      label.addEventListener('blur', function() {
        this.style.background = 'transparent';
        this.style.border = 'none';
        this.style.boxShadow = 'none';
        this.style.padding = '0';
        this.style.borderRadius = '0';
        this.style.whiteSpace = 'nowrap'; /* Prevent wrapping when blurred */
        this.style.textOverflow = 'ellipsis'; /* Add ellipsis when blurred */
      });

      // Double-click to focus/edit
      label.addEventListener('dblclick', function() {
        this.focus();
      });

      // Dynamic width adjustment for the input field and horizontal centering for 'num' labels
      const measureSpan = document.createElement('span');
      measureSpan.style.visibility = 'hidden';
      measureSpan.style.whiteSpace = 'pre'; // Preserve whitespace
      measureSpan.style.fontSize = '20px';
      measureSpan.style.fontFamily = 'Inter, sans-serif'; // Match label font
      document.body.appendChild(measureSpan); // Append to body to measure correctly

      // Capture the bar object for the label's input listener
      const currentBarForLabel = selectedBar;

      label.addEventListener('input', function() {
        measureSpan.textContent = this.value || ' '; // Use ' ' for empty to get a minimum width
        const desiredWidth = Math.min(150, Math.max(40, measureSpan.offsetWidth + 4)); // Max 150px
        this.style.width = `${desiredWidth}px`;
        
        if (this.dataset.type === 'num') {
            const barX = currentBarForLabel.xRatio * gridSize;
            const barWidth = currentBarForLabel.widthRatio * gridSize;
            this.style.left = `${barX + barWidth / 2 - this.offsetWidth / 2}px`;
        }
      });
      
      // Append the label to the canvas container
      document.getElementById("canvas-container").appendChild(label);
      
      // Trigger initial width calculation and positioning
      const event = new Event('input');
      label.dispatchEvent(event);
      
      // Remove the temporary measureSpan after use to prevent whitespace
      document.body.removeChild(measureSpan);
    }

    // Initial setup on window load
    window.addEventListener('load', () => {
      window.resizeCanvas(); // Set initial canvas size and draw background
      // No initial bar added automatically anymore
    });
    
    // Resize canvases when window is resized
    window.addEventListener('resize', window.resizeCanvas);

    /**
     * Helper function to create a deep clone of the bars array,
     * converting HTML label elements to serializable data.
     * @returns {Array} A deep copy of the bars array with serializable label data.
     */
    function getSerializableBarsState() {
      return bars.map(bar => {
        const serializableBar = { ...bar };
        if (serializableBar.labels) {
          const serializedLabels = {};
          for (const type in serializableBar.labels) {
            const labelData = serializableBar.labels[type]; // This is now { element, offsetX, offsetY, value } or { element, offsetY, value }
            if (type === 'text') {
                serializedLabels[type] = {
                    value: labelData.element.value,
                    offsetX: labelData.offsetX,
                    offsetY: labelData.offsetY
                };
            } else { // type === 'num'
                serializedLabels[type] = {
                    value: labelData.element.value,
                    offsetY: labelData.offsetY
                };
            }
          }
          serializableBar.labels = serializedLabels;
        }
        return serializableBar;
      });
    }

    /**
     * Helper function to restore labels from serializable data.
     * @param {Object} bar - The bar object to restore labels for.
     * @param {string} type - The type of label ('text' or 'num').
     * @param {Object} labelData - The serializable label data ({ value, offsetX, offsetY } or { value, offsetY }).
     */
    function restoreLabel(bar, type, labelData) {
      const label = document.createElement('input');
      label.type = 'text';
      label.value = labelData.value || '';
      label.dataset.type = type;
      label.classList.add('bar-label');
      
      label.style.position = 'absolute';
      label.style.fontSize = '20px';
      label.style.zIndex = '100';
      label.style.cursor = 'pointer';
      label.style.minWidth = '40px';
      label.style.textAlign = type === 'num' ? 'center' : 'left';
      label.style.outline = 'none';

      // Restore styling based on blur state (transparent)
      label.style.background = 'transparent';
      label.style.border = 'none';
      label.style.boxShadow = 'none';
      label.style.padding = '0';
      label.style.borderRadius = '0';
      label.style.whiteSpace = 'nowrap';
      label.style.textOverflow = 'ellipsis';


      // Event listener to show editing UI when focused
      label.addEventListener('focus', function() {
        this.style.background = '#fff'; this.style.border = '1px solid #888'; this.style.boxShadow = '0 0 2px rgba(0,0,0,0.2)'; this.style.padding = '1px 4px'; this.style.borderRadius = '3px';
        this.style.whiteSpace = 'normal';
        this.style.textOverflow = 'clip';
      });
      // Event listener to hide editing UI when blurred
      label.addEventListener('blur', function() {
        this.style.background = 'transparent'; this.style.border = 'none'; this.style.boxShadow = 'none'; this.style.padding = '0'; this.style.borderRadius = '0';
        this.style.whiteSpace = 'nowrap';
        this.style.textOverflow = 'ellipsis';
      });
      label.addEventListener('dblclick', function() {
        this.focus();
      });

      const measureSpan = document.createElement('span');
      measureSpan.style.visibility = 'hidden'; measureSpan.style.whiteSpace = 'pre'; measureSpan.style.fontSize = '20px'; measureSpan.style.fontFamily = 'Inter, sans-serif';
      document.body.appendChild(measureSpan);

      // Capture the bar object for the label's input listener
      const currentBarForRestoredLabel = bar;

      label.addEventListener('input', function() {
        measureSpan.textContent = this.value || ' '; 
        const desiredWidth = Math.min(150, Math.max(40, measureSpan.offsetWidth + 4));
        this.style.width = `${desiredWidth}px`; 
        
        if (this.dataset.type === 'num') {
          const barX = currentBarForRestoredLabel.xRatio * gridSize;
          const barWidth = currentBarForRestoredLabel.widthRatio * gridSize;
          this.style.left = `${barX + barWidth/2 - this.offsetWidth/2}px`;
        }
      });
      
      document.getElementById("canvas-container").appendChild(label);
      
      // Store reference to the DOM element and its offsets in the bar object
      bar.labels[type] = {
          element: label,
          offsetX: labelData.offsetX, // Will be undefined for num, handled by updateLabels
          offsetY: labelData.offsetY,
          value: label.value
      };

      // Trigger initial width calculation and positioning
      label.dispatchEvent(new Event('input'));
      
      // Remove the temporary measureSpan after use to prevent whitespace
      document.body.removeChild(measureSpan);
    }

    /**
     * Toggles drawing mode on/off.
     * @param {HTMLElement} btn - The button element that was clicked.
     * @param {string} color - The color to set for the pen.
     */
    window.toggleDrawMode = function(btn, color) {
      const isActive = btn && btn.classList.contains('active'); // Check if button exists and is active
      // Remove 'active' class from all color buttons
      document.querySelectorAll('.color-button').forEach(b => b.classList.remove('active'));
      
      if (!isActive) {
        if (btn) btn.classList.add('active'); // If button exists, add 'active' class to the clicked button
        penColor = color; // Set pen color
        penMode = true; // Enable pen mode
        currentMode = 'draw'; // Set mode to draw
        drawingCanvas.style.pointerEvents = 'auto'; // Enable drawing canvas interaction
        canvas.style.pointerEvents = 'none'; // Disable main canvas interaction
      } else {
        penMode = false; // Disable pen mode
        currentMode = 'select'; // Set mode to select
        drawingCanvas.style.pointerEvents = 'none'; // Disable drawing canvas interaction
        canvas.style.pointerEvents = 'auto'; // Enable main canvas interaction
      }
      // Hide floating bar tools when switching modes
      document.getElementById('floating-bar-tools').style.display = 'none';
      selectedBar = null; // Deselect any bar
      drawAll(); // Redraw to remove selection outline
    }

    /**
     * Undoes the last drawing action.
     */
    window.undoDraw = function() {
      if (undoStack.length > 0) {
        redoStack.push(drawingCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height)); // Save current state for undo
        const lastState = undoStack.pop(); // Get previous state from undo stack
        drawingCtx.putImageData(lastState, 0, 0); // Restore previous state
        drawingImage = drawingCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height); // Update drawingImage
      }
    }

    /**
     * Redoes the last undone drawing action.
     */
    window.redoDraw = function() {
      if (redoStack.length > 0) {
        undoStack.push(drawingCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height)); // Save current state to undo stack
        const nextState = redoStack.pop(); // Get next state from redo stack
        drawingCtx.putImageData(nextState, 0, 0); // Restore next state
        drawingImage = drawingCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height); // Update drawingImage
      }
    }

    /**
     * Undoes the last bar manipulation action.
     * Restores previous bar states and recreates labels.
     */
    window.undoBar = function() {
      if (barUndoStack.length > 0) {
        barRedoStack.push(JSON.parse(JSON.stringify({ bars: getSerializableBarsState() })));
        
        const prevState = barUndoStack.pop();
        bars = prevState.bars;
        
        // Remove all existing HTML labels
        document.querySelectorAll('#canvas-container input.bar-label').forEach(el => el.remove());

        // Recreate labels for the restored bars
        bars.forEach(bar => {
          if (bar.labels) {
            for (let type in bar.labels) {
              restoreLabel(bar, type, bar.labels[type]);
            }
          }
        });
        updateLabels();
        drawAll();
        positionFloatingBarTools(); // Reposition floating tools after undo
      }
    }

    /**
     * Redoes the last undone bar manipulation action.
     * Restores next bar states and recreates labels.
     */
    window.redoBar = function() {
      if (barRedoStack.length > 0) {
        barUndoStack.push(JSON.parse(JSON.stringify({ bars: getSerializableBarsState() })));
        
        const nextState = barRedoStack.pop();
        bars = nextState.bars;
        
        // Remove all existing HTML labels
        document.querySelectorAll('#canvas-container input.bar-label').forEach(el => el.remove());

        // Recreate labels for the restored bars
        bars.forEach(bar => {
          if (bar.labels) {
            for (let type in bar.labels) {
              restoreLabel(bar, type, bar.labels[type]);
            }
          }
        });
        updateLabels();
        drawAll();
        positionFloatingBarTools(); // Reposition floating tools after redo
      }
    }

    /**
     * Toggles the arrow display for the selected bar.
     */
    window.toggleArrow = function() {
      if (selectedBar) {
        barUndoStack.push(JSON.parse(JSON.stringify({ bars: getSerializableBarsState() })));
        barRedoStack = [];
        selectedBar.arrow = !selectedBar.arrow; // Toggle arrow property
        drawAll(); // Redraw to show/hide arrow
        positionFloatingBarTools(); // Reposition floating tools in case arrow affects bar bounds visually
      }
    }

    /**
     * Displays a menu to split the selected bar into multiple segments.
     */
    window.splitBar = function() {
      if (!selectedBar) return; // No bar selected

      let menu = document.getElementById("split-menu");
      if (!menu) {
        // Create the split menu if it's not already in the DOM
        menu = document.createElement("div");
        menu.id = "split-menu";
        menu.style.position = "absolute";
        menu.style.display = "flex";
        menu.style.flexDirection = "column";
        menu.style.gap = "4px";
        menu.style.background = "#fff";
        menu.style.border = "1px solid #ccc";
        menu.style.padding = "6px";
        menu.style.borderRadius = "6px";
        menu.style.zIndex = 99;
        
        // Add buttons for splitting from 1 to 12
        for (let i = 1; i <= 12; i++) {
          const b = document.createElement("button");
          b.innerText = i;
          b.onclick = () => {
            barUndoStack.push(JSON.parse(JSON.stringify({ bars: getSerializableBarsState() })));
            barRedoStack = [];
            selectedBar.split = i; // Set split count
            menu.style.display = 'none'; // Hide menu after selection
            drawAll(); // Redraw bar with splits
            positionFloatingBarTools(); // Reposition floating tools
          };
          menu.appendChild(b);
        }
        document.body.appendChild(menu); // Append menu to body
      } else {
        // If menu already exists, just show it
        menu.style.display = 'flex';
      }

      // Position the menu near the selected bar
      const bx = selectedBar.xRatio * gridSize;
      const by = selectedBar.yRatio * gridSize;
      menu.style.left = `${bx + 10}px`;
      menu.style.top = `${by - 10}px`;
    }

    /**
     * Deletes the currently selected bar or textbox.
     */
    window.deleteSelectedElement = function() {
      // Save current state for undo before deletion
      barUndoStack.push(JSON.parse(JSON.stringify({ bars: getSerializableBarsState() })));
      barRedoStack = [];

      if (selectedBar) {
        // Remove associated HTML labels from the DOM
        if (selectedBar.labels) {
          for (let type in selectedBar.labels) {
            selectedBar.labels[type].element.remove(); // Remove DOM element
          }
        }

        // Filter out the selected bar from the array
        bars = bars.filter(b => b !== selectedBar);
        selectedBar = null; // Deselect the bar
        document.getElementById("floating-bar-tools").style.display = "none"; // Hide floating bar tools
        drawAll(); // Redraw all remaining bars
      } 
    }

    /**
     * Updates the position of all HTML labels based on their associated bars' current positions.
     */
    function updateLabels() {
      for (let bar of bars) {
        if (!bar.labels) continue; // Skip if no labels
        for (let type in bar.labels) {
          const labelData = bar.labels[type]; // This now contains { element, offsetX, offsetY, value } or { element, offsetY, value }
          const label = labelData.element; // Get the actual DOM element

          const barX = bar.xRatio * gridSize;
          const barY = bar.yRatio * gridSize;
          const barWidth = bar.widthRatio * gridSize; // Needed for num label centering
          
          if (type === 'text') {
            label.style.left = `${barX + labelData.offsetX}px`;
            label.style.top = `${barY + labelData.offsetY}px`;
          } else { // type === 'num'
            // Only update Y based on fixed offsetY
            label.style.top = `${barY + labelData.offsetY}px`;
            // Recalculate X based on bar center and label's current width
            // This relies on the label's 'input' listener having set its width correctly
            label.style.left = `${barX + barWidth / 2 - label.offsetWidth / 2}px`;
          }
        }
      }
    }

    /**
     * Clears all bars, drawings, and resets the application state.
     */
    window.clearAll = function() {
      bars = []; // Clear bars array
      selectedBar = null; // Deselect any bar
      barRedoStack = []; // Clear bar redo stack
      
      // Clear drawing canvas and reset drawing image
      drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
      drawingImage = drawingCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height);
      undoStack = []; // Clear drawing undo stack
      redoStack = []; // Clear drawing redo stack
      
      // Remove all dynamically added HTML elements (labels, textboxes, split menu)
      document.querySelectorAll('#canvas-container input.bar-label, #canvas-container textarea.text-box, #split-menu').forEach(el => {
        // Exclude the problem generator input/output elements from being cleared
        if (el.id !== 'problemKeywords' && el.id !== 'problemOutput' && el.id !== 'solutionOutput') { 
          el.remove();
        }
      });
      
      document.getElementById("floating-bar-tools").style.display = "none"; // Hide floating bar tools
      drawAll(); // Redraw (will be empty)

      // Clear persistent problem display and solution bubble
      persistentProblemDisplay.textContent = '';
      persistentProblemDisplay.style.display = 'none';
      window.closeSolutionBubble(); // Close and clear the solution bubble
      window.closeBarModelIdeaModal(); // Close and clear the bar model idea modal
    }

    /**
     * Toggles the visibility of the "About" modal.
     */
    window.toggleAbout = function() {
      const modal = document.getElementById("aboutModal");
      modal.style.display = modal.style.display === "none" ? "block" : "none";
      // Close other modals if open
      document.getElementById("problemGeneratorModal").style.display = "none";
      document.getElementById("versionHistoryModal").style.display = "none";
      window.closeSolutionBubble();
      window.closeBarModelIdeaModal();
    }

    /**
     * Toggles the visibility of the Version History modal.
     */
    window.toggleVersionHistory = function() {
      const modal = document.getElementById("versionHistoryModal");
      modal.style.display = modal.style.display === "none" ? "block" : "none";
      // Close other modals if open
      document.getElementById("aboutModal").style.display = "none";
      document.getElementById("problemGeneratorModal").style.display = "none";
      window.closeSolutionBubble();
      window.closeBarModelIdeaModal();
    }

    /**
     * Toggles the visibility of the Problem Generator modal.
     */
    window.toggleProblemGenerator = function() {
      const modal = document.getElementById("problemGeneratorModal");
      modal.style.display = modal.style.display === "none" ? "block" : "none";
      // Clear problem and solution output when opening the modal
      document.getElementById('problemOutput').textContent = 'Your generated problem will appear here.';
      document.getElementById('loadingIndicator').style.display = 'none';
      // Close other modals if open
      document.getElementById("aboutModal").style.display = "none";
      document.getElementById("versionHistoryModal").style.display = "none";
      window.closeSolutionBubble();
      window.closeBarModelIdeaModal();
    }

    /**
     * Displays the current step of the solution in the solution bubble.
     * Manages "Previous" and "Next" button states.
     */
    function displayCurrentStep() {
        const solutionContent = document.getElementById('solutionContent');
        const prevBtn = document.getElementById('prevStepBtn');
        const nextBtn = document.getElementById('nextStepBtn'); 
        console.log('Solution Steps:', solutionSteps); // Debugging
        console.log('Current Step Index:', currentStepIndex); // Debugging

        if (solutionSteps.length > 0) {
            solutionContent.innerHTML = solutionSteps[currentStepIndex];
            renderMathInGivenElement(solutionContent); // Render LaTeX in solution step
            prevBtn.disabled = (currentStepIndex === 0);
            nextBtn.disabled = (currentStepIndex === solutionSteps.length - 1);
        } else {
            solutionContent.textContent = "No solution steps available.";
            prevBtn.disabled = true;
            nextBtn.disabled = true;
        }
    }

    /**
     * Moves to the next step in the solution carousel.
     */
    window.showNextStep = function() {
        if (currentStepIndex < solutionSteps.length - 1) {
            currentStepIndex++;
            displayCurrentStep();
        }
    }

    /**
     * Moves to the previous step in the solution carousel.
     */
    window.showPreviousStep = function() {
        if (currentStepIndex > 0) {
            currentStepIndex--;
            displayCurrentStep();
        }
    }

    /**
     * Closes and clears the solution tips bubble.
     */
    window.closeSolutionBubble = function() {
        document.getElementById('solutionBubble').style.display = 'none';
        solutionSteps = []; // Clear steps when closed
        currentStepIndex = 0;
        document.getElementById('solutionContent').textContent = ''; // Clear content
    }

    /**
     * Toggles the visibility of the Bar Model Idea modal.
     */
    window.toggleBarModelIdeaModal = function() {
        const modal = document.getElementById("barModelIdeaModal");
        modal.style.display = modal.style.display === "none" ? "block" : "none";
        // Close other modals if open
        document.getElementById("aboutModal").style.display = "none";
        document.getElementById("problemGeneratorModal").style.display = "none";
        document.getElementById("versionHistoryModal").style.display = "none";
        window.closeSolutionBubble();
        // Clear content when opening
        document.getElementById('barModelIdeaContent').textContent = 'Your bar model idea will appear here.';
        document.getElementById('barModelIdeaLoading').style.display = 'none';
    }

    /**
     * Closes the Bar Model Idea modal.
     */
    window.closeBarModelIdeaModal = function() {
        document.getElementById('barModelIdeaModal').style.display = 'none';
        document.getElementById('barModelIdeaContent').textContent = '';
    }

    /**
     * Generates a word problem using the Gemini API based on user keywords.
     */
    window.generateProblem = async function() {
      const keywordsInput = document.getElementById('problemKeywords');
      const numberTypes = Array.from(document.querySelectorAll('input[name="numberType"]:checked')).map(cb => cb.value);
      const minNumberRange = document.getElementById('minNumberRange').value;
      const maxNumberRange = document.getElementById('maxNumberRange').value;
      const operations = Array.from(document.querySelectorAll('input[name="operation"]:checked')).map(cb => cb.value);
      const barModelTypes = Array.from(document.querySelectorAll('input[name="barModelType"]:checked')).map(cb => cb.value);
      const problemTheme = document.querySelector('input[name="problemTheme"]:checked').value;
      const problemLanguage = document.querySelector('input[name="problemLanguage"]:checked').value;

      const problemOutput = document.getElementById('problemOutput');
      const loadingIndicator = document.getElementById('loadingIndicator');
      const keywords = keywordsInput.value.trim();

      // Clear previous problem and solution bubble
      problemOutput.textContent = '';
      persistentProblemDisplay.textContent = '';
      persistentProblemDisplay.style.display = 'none';
      window.closeSolutionBubble(); // Ensure solution bubble is closed
      window.closeBarModelIdeaModal(); // Ensure bar model idea modal is closed

      loadingIndicator.style.display = 'block'; // Show loading indicator

      // Store the selected language for later use in solveProblem and generateBarModelIdea
      lastProblemLanguage = problemLanguage;

      try {
        let chatHistory = [];
        let prompt = `Generate a single, coherent, and solvable math word problem suitable for elementary school students in Malaysia. The problem should clearly state the given information and what needs to be found.`;

        if (numberTypes.length > 0) {
            prompt += ` It must use numbers of type: ${numberTypes.join(', ')}.`;
            if (numberTypes.includes('fractions')) {
                prompt += ` If fractions are included, represent them in LaTeX math format (e.g., $\\frac{1}{2}$). Ensure fractions remain in proper/improper form and are NOT converted to mixed numbers unless the problem itself specifies mixed numbers.`;
            }
        }
        
        prompt += ` The numbers should be between ${minNumberRange} and ${maxNumberRange}.`;

        if (operations.length > 0) {
            prompt += ` It should involve the following operations: ${operations.join(', ')}.`;
        }

        if (barModelTypes.length > 0) {
            prompt += ` The problem should be solvable using a bar model of type: ${barModelTypes.join(' or ')}.`;
            if (barModelTypes.includes('comparison')) {
                prompt += ` For 'comparison' problems, focus on scenarios where quantities are compared (e.g., "A has X more than B", "difference between two amounts").`;
            }
            if (barModelTypes.includes('equal parts')) {
                prompt += ` For 'equal parts' problems, focus on scenarios where a whole is divided into equal parts (e.g., "1/3 of the total", "each person gets an equal share").`;
            }
        }
        
        if (problemTheme !== 'any') {
            prompt += ` The theme should be related to ${problemTheme}.`;
        }
        
        if (keywords) {
            prompt += ` Incorporate the following concepts or keywords: "${keywords}".`;
        }
        
        // Add Malaysian context specifics
        prompt += ` If money is involved, use 'RM' for Malaysian Ringgit. Ensure the problem is culturally relevant to Malaysia.`;

        prompt += ` Do not include any introductory phrases like "Here is a simple math word problem." Respond in ${problemLanguage}.`;

        chatHistory.push({ role: "user", parts: [{ text: prompt }] });
        const payload = { contents: chatHistory };
        const apiKey = "AIzaSyAOEDAX_YUrTPgsWnbXUar3VGcz4LqHCGk"; 
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
        
        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        
        const result = await response.json();

        if (result.candidates && result.candidates.length > 0 &&
            result.candidates[0].content && result.candidates[0].content.parts &&
            result.candidates[0].content.parts.length > 0) {
          const text = result.candidates[0].content.parts[0].text;
          problemOutput.innerHTML = text; // Use innerHTML to allow KaTeX to render
          persistentProblemDisplay.innerHTML = text; // Use innerHTML to allow KaTeX to render
          persistentProblemDisplay.style.display = 'block'; // Show persistent display
          renderMathInGivenElement(problemOutput); // Render LaTeX in modal output
          renderMathInGivenElement(persistentProblemDisplay); // Render LaTeX in persistent display
          window.toggleProblemGenerator(); // Close the modal after generation
        } else {
          problemOutput.textContent = "Failed to generate problem. Please try again.";
          persistentProblemDisplay.textContent = ''; // Clear persistent display on error
          persistentProblemDisplay.style.display = 'none';
          console.error("Gemini API response structure unexpected:", result);
        }
      } catch (error) {
        problemOutput.textContent = "Error generating problem. Please check your network connection or try again later.";
        persistentProblemDisplay.textContent = ''; // Clear persistent display on error
        persistentProblemDisplay.style.display = 'none';
        console.error("Error calling Gemini API:", error);
      } finally {
        loadingIndicator.style.display = 'none'; // Hide loading indicator
      }
    }

    /**
     * Solves the currently displayed problem using the Gemini API.
     */
    window.solveProblem = async function() {
      // Get the problem from the persistent display
      const problemText = persistentProblemDisplay.textContent;
      const loadingIndicator = document.getElementById('loadingIndicator');
      const solutionBubble = document.getElementById('solutionBubble');

      // Clear previous solution steps and hide the bubble initially
      solutionSteps = [];
      currentStepIndex = 0;
      solutionBubble.style.display = 'none';
      document.getElementById('solutionContent').textContent = ''; // Clear content
      window.closeBarModelIdeaModal(); // Ensure bar model idea modal is closed

      if (!problemText || problemText.trim() === '' || problemText === 'Your generated problem will appear here.') {
        document.getElementById('solutionContent').textContent = "Please generate a problem first before trying to solve it.";
        solutionBubble.style.display = 'flex'; // Show bubble with error
        document.getElementById('prevStepBtn').style.display = 'none'; // Hide buttons
        document.getElementById('nextStepBtn').style.display = 'none';
        return;
      }

      loadingIndicator.style.display = 'block'; // Show loading indicator

      try {
        let chatHistory = [];
        // Request numbered steps from the AI with bold subtitles, emphasizing brevity
        const prompt = `Provide a clear, simple, and very concise step-by-step solution or helpful tips to solve the following math word problem. Each step should be a numbered item. If a step requires a sub-explanation, use bold text for a short subtitle within that step. Keep each step's explanation to one or two sentences, easy for elementary school students to understand, and avoid overly complex language. If mathematical expressions are part of the solution, use LaTeX math format (e.g., $\\frac{1}{2}$, $5 \\times 3$). Ensure all numbers, especially fractions, maintain their original proper/improper fraction format (e.g., $\\frac{1}{2}$) as presented in the problem, and *do not convert them to mixed numbers* unless the problem itself uses mixed numbers. Respond in ${lastProblemLanguage}. Problem: "${problemText}"`;
        chatHistory.push({ role: "user", parts: [{ text: prompt }] });
        const payload = { contents: chatHistory };
        const apiKey = "AIzaSyAOEDAX_YUrTPgsWnbXUar3VGcz4LqHCGk"; 
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
        
        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        
        const result = await response.json();
        console.log("Gemini API solution response:", result); // Added for debugging

        if (result.candidates && result.candidates.length > 0 &&
            result.candidates[0].content && result.candidates[0].content.parts &&
            result.candidates[0].content.parts.length > 0) {
          const fullSolutionText = result.candidates[0].content.parts[0].text;
          console.log("Full Solution Text from API:", fullSolutionText); // Added for debugging

          // Parse the solution into steps based on numbered list, wrapping each in a paragraph
          solutionSteps = fullSolutionText.split(/\n\d+\.\s|\d+\.\s/).filter(step => step.trim() !== '').map(step => `<p>${step.trim()}</p>`);
          
          if (solutionSteps.length === 0 && fullSolutionText.trim() !== '') {
              // Fallback if parsing fails but there's content, treat as one step
              solutionSteps = [`<p>${fullSolutionText}</p>`];
          } else if (solutionSteps.length === 0 && fullSolutionText.trim() === '') {
              solutionSteps = ["<p>No solution steps could be generated.</p>"];
          }

          currentStepIndex = 0;
          displayCurrentStep();
          solutionBubble.style.display = 'flex'; // Show the bubble
          // Show/hide navigation buttons based on number of steps
          document.getElementById('prevStepBtn').style.display = solutionSteps.length > 1 ? 'inline-block' : 'none';
          document.getElementById('nextStepBtn').style.display = solutionSteps.length > 1 ? 'inline-block' : 'none';

        } else {
          document.getElementById('solutionContent').textContent = "Failed to get solution. Please try again.";
          solutionBubble.style.display = 'flex';
          document.getElementById('prevStepBtn').style.display = 'none';
          document.getElementById('nextStepBtn').style.display = 'none';
          console.error("Gemini API response structure unexpected:", result);
        }
      } catch (error) {
        document.getElementById('solutionContent').textContent = "Error getting solution. Please check your network connection or try again later.";
        solutionBubble.style.display = 'flex';
        document.getElementById('prevStepBtn').style.display = 'none';
        document.getElementById('nextStepBtn').style.display = 'none';
        console.error("Error calling Gemini API for solution:", error);
      } finally {
        loadingIndicator.style.display = 'none'; // Hide loading indicator
      }
    }

    /**
     * Generates a bar model idea for the currently displayed problem using the Gemini API.
     */
    window.generateBarModelIdea = async function() {
      const problemText = persistentProblemDisplay.textContent;
      const barModelIdeaContent = document.getElementById('barModelIdeaContent');
      const barModelIdeaLoading = document.getElementById('barModelIdeaLoading');

      // Clear previous content and show modal
      barModelIdeaContent.textContent = '';
      barModelIdeaLoading.style.display = 'block';
      window.toggleBarModelIdeaModal(); // Open and clear other modals

      if (!problemText || problemText.trim() === '' || problemText === 'Your generated problem will appear here.') {
        barModelIdeaContent.textContent = "Please generate a problem first before trying to get a bar model idea.";
        barModelIdeaLoading.style.display = 'none';
        return;
      }

      try {
        let chatHistory = [];
        const prompt = `Given the following math word problem, describe how to represent it using bar models. Focus on the visual structure, number of bars, their relative sizes, and what each part represents. Do not solve the problem or provide any numerical answers. Keep the description concise and easy to understand for elementary students. Ensure all numbers, especially fractions, maintain their original proper/improper fraction format (e.g., $\\frac{1}{2}$) as presented in the problem, and *do not convert them to mixed numbers*. Respond in ${lastProblemLanguage}. Problem: "${problemText}"`;
        chatHistory.push({ role: "user", parts: [{ text: prompt }] });
        const payload = { contents: chatHistory };
        const apiKey = "AIzaSyAOEDAX_YUrTPgsWnbXUar3VGcz4LqHCGk"; 
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
        
        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        
        const result = await response.json();

        if (result.candidates && result.candidates.length > 0 &&
            result.candidates[0].content && result.candidates[0].content.parts &&
            result.candidates[0].content.parts.length > 0) {
          const text = result.candidates[0].content.parts[0].text;
          barModelIdeaContent.innerHTML = text; // Use innerHTML to allow KaTeX to render
          renderMathInGivenElement(barModelIdeaContent); // Render LaTeX
        } else {
          barModelIdeaContent.textContent = "Failed to generate bar model idea. Please try again.";
          console.error("Gemini API response structure unexpected for bar model idea:", result);
        }
      } catch (error) {
        barModelIdeaContent.textContent = "Error generating bar model idea. Please check your network connection or try again later.";
        console.error("Error calling Gemini API for bar model idea:", error);
      } finally {
        loadingIndicator.style.display = 'none'; // Hide loading indicator
      }
    }

    /**
     * Exports the canvas content as a PNG image.
     * Includes all canvas layers (background, bars, drawing) and HTML elements (labels, problem, copyright).
     */
    window.exportCanvas = function() {
      // Create a temporary canvas to merge all layers
      const exportCanvasEl = document.createElement('canvas');
      // Set canvas dimensions to encompass all content
      const allElements = document.querySelectorAll('#canvas-container, #persistentProblemDisplay, div[style*="bottom: 90px; right: 12px;"], input.bar-label');
      let minX = window.innerWidth;
      let minY = window.innerHeight;
      let maxX = 0;
      let maxY = 0;

      allElements.forEach(el => {
          const rect = el.getBoundingClientRect();
          minX = Math.min(minX, rect.left);
          minY = Math.min(minY, rect.top);
          maxX = Math.max(maxX, rect.right);
          maxY = Math.max(maxY, rect.bottom);
      });

      // Add some padding to the exported image
      const padding = 20;
      exportCanvasEl.width = (maxX - minX) + 2 * padding;
      exportCanvasEl.height = (maxY - minY) + 2 * padding;
      const exportCtx = exportCanvasEl.getContext('2d');
      exportCtx.fillStyle = 'white';
      exportCtx.fillRect(0, 0, exportCanvasEl.width, exportCanvasEl.height); // Fill with white background

      // Adjust drawing origin to account for minX, minY and padding
      const offsetX = -minX + padding;
      const offsetY = -minY + padding;

      // Draw background (shifted)
      exportCtx.drawImage(bgCanvas, offsetX, offsetY, bgCanvas.width, bgCanvas.height);
      // Draw bars (shifted)
      exportCtx.drawImage(canvas, offsetX, offsetY, canvas.width, canvas.height);
      // Draw freehand drawing (shifted)
      exportCtx.drawImage(drawingCanvas, offsetX, offsetY, drawingCanvas.width, drawingCanvas.height);

      // Collect all HTML elements to be drawn
      const htmlElementsToDraw = [];

      // Add bar labels
      document.querySelectorAll('#canvas-container input.bar-label').forEach(el => {
        htmlElementsToDraw.push({
          element: el,
          x: el.getBoundingClientRect().left + offsetX,
          y: el.getBoundingClientRect().top + offsetY
        });
      });

      // Add persistent problem display
      const problemDisplay = document.getElementById('persistentProblemDisplay');
      if (problemDisplay && problemDisplay.style.display !== 'none') {
        htmlElementsToDraw.push({
          element: problemDisplay,
          x: problemDisplay.getBoundingClientRect().left + offsetX,
          y: problemDisplay.getBoundingClientRect().top + offsetY
        });
      }

      // Add copyright notice
      const copyrightNotice = document.querySelector('div[style*="bottom: 90px; right: 12px;"]');
      if (copyrightNotice) { 
        htmlElementsToDraw.push({
          element: copyrightNotice,
          x: copyrightNotice.getBoundingClientRect().left + offsetX,
          y: copyrightNotice.getBoundingClientRect().top + offsetY
        });
      }

      // Add Bar Model Idea Modal content if visible
      const barModelIdeaModal = document.getElementById('barModelIdeaModal');
      const barModelIdeaContent = document.getElementById('barModelIdeaContent');
      if (barModelIdeaModal && barModelIdeaModal.style.display !== 'none' && barModelIdeaContent.textContent.trim() !== '') {
          htmlElementsToDraw.push({
              element: barModelIdeaContent,
              x: barModelIdeaContent.getBoundingClientRect().left + offsetX,
              y: barModelIdeaContent.getBoundingClientRect().top + offsetY
          });
      }


      let elementsToProcess = htmlElementsToDraw.length;

      // If no HTML elements, just download the canvas content
      if (elementsToProcess === 0) {
        downloadCanvas(exportCanvasEl);
        return;
      }

      htmlElementsToDraw.forEach(item => {
        const el = item.element;
        const x = item.x;
        const y = item.y;

        const computedStyle = window.getComputedStyle(el);
        let htmlContent;
        if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
          htmlContent = el.value;
        } else {
          htmlContent = el.innerHTML;
        }

        // Create a temporary SVG element to render HTML element content
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${el.offsetWidth}" height="${el.offsetHeight}">
                       <foreignObject width="100%" height="100%">
                         <div xmlns="http://www.w3.org/1999/xhtml" style="
                           font-family: '${computedStyle.fontFamily}';
                           font-size: ${computedStyle.fontSize};
                           color: ${computedStyle.color};
                           text-align: ${computedStyle.textAlign};
                           padding: ${computedStyle.padding};
                           border: ${computedStyle.border};
                           background: ${computedStyle.backgroundColor};
                           box-shadow: ${computedStyle.boxShadow};
                           border-radius: ${computedStyle.borderRadius};
                           line-height: ${computedStyle.lineHeight};
                           white-space: ${computedStyle.whiteSpace};
                           word-wrap: ${computedStyle.wordWrap};
                           overflow: ${computedStyle.overflow};
                           text-overflow: ${computedStyle.textOverflow};
                           display: ${computedStyle.display};
                           justify-content: ${computedStyle.justifyContent};
                           align-items: ${computedStyle.alignItems};
                           gap: ${computedStyle.gap};
                           font-weight: ${computedStyle.fontWeight};
                           font-style: ${computedStyle.fontStyle};
                         ">
                           ${htmlContent.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}
                         </div>
                       </foreignObject>
                     </svg>`;
        const img = new Image();
        img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svg)));
        img.onload = () => {
          exportCtx.drawImage(img, x, y);
          elementsToProcess--;
          if (elementsToProcess === 0) {
            downloadCanvas(exportCanvasEl);
          }
        };
        img.onerror = (err) => {
          console.error("Error loading SVG for export:", err);
          alert("Error exporting image. Please ensure all elements are loaded correctly.");
          exportCanvasEl.remove();
          elementsToProcess--; // Decrement even on error to avoid hanging
          if (elementsToProcess === 0) {
            downloadCanvas(exportCanvasEl); // Attempt to download what was drawn
          }
        };
      });

      function downloadCanvas(canvasToDownload) {
        const dataURL = canvasToDownload.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = dataURL;
        a.download = 'bar_model.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        canvasToDownload.remove(); // Clean up temporary canvas
      }
    }


    // --- Touch Event Handlers for Drawing Canvas ---
    drawingCanvas.addEventListener('touchstart', handleTouchStart);
    drawingCanvas.addEventListener('touchmove', handleTouchMove);
    drawingCanvas.addEventListener('touchend', handleTouchEnd);

    function handleTouchStart(e) {
      if (!penMode) return; // Only draw if pen mode is active
      const touch = e.touches[0];
      const rect = drawingCanvas.getBoundingClientRect();
      const mx = touch.clientX - rect.left;
      const my = touch.clientY - rect.top;
      
      undoStack.push(drawingCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height)); // Save current state for undo
      redoStack = []; // Clear redo stack
      
      drawingCtx.beginPath();
      drawingCtx.strokeStyle = penColor;
      drawingCtx.lineWidth = penSize;
      drawingCtx.lineCap = 'round'; // Added for smoother lines
      drawingCtx.lineJoin = 'round'; // Added for smoother lines
      drawingCtx.moveTo(mx, my);
      isTouchDrawing = true;
      e.preventDefault(); // Prevent scrolling/zooming
    }

    function handleTouchMove(e) {
      if (!isTouchDrawing || !penMode) return;
      const touch = e.touches[0];
      const rect = drawingCanvas.getBoundingClientRect();
      const mx = touch.clientX - rect.left;
      const my = touch.clientY - rect.top;
      drawingCtx.lineTo(mx, my);
      drawingCtx.stroke();
      e.preventDefault(); // Prevent scrolling/zooming
    }

    function handleTouchEnd() {
      if (isTouchDrawing && penMode) {
        isTouchDrawing = false;
        drawingImage = drawingCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height); // Update drawingImage
      }
    }

    /**
     * Positions the floating bar tools menu near the selected bar.
     */
    function positionFloatingBarTools() {
      const floatingTools = document.getElementById('floating-bar-tools');
      if (selectedBar && floatingTools) {
        const barX = selectedBar.xRatio * gridSize;
        const barY = selectedBar.yRatio * gridSize;
        const barWidth = selectedBar.widthRatio * gridSize;
        const barHeight = selectedBar.heightRatio * gridSize;

        const canvasRect = canvas.getBoundingClientRect();
        const containerRect = document.getElementById('canvas-container').getBoundingClientRect();

        let targetLeft = barX + barWidth / 2 - floatingTools.offsetWidth / 2;
        let targetTop;

        // Force position below the bar as requested
        targetTop = barY + barHeight + 10; // 10px padding below

        // Adjust for container offset (canvas relative to its container)
        targetLeft += canvasRect.left - containerRect.left;
        targetTop += canvasRect.top - containerRect.top;

        // Ensure it stays within the canvas container bounds
        targetLeft = Math.max(0, Math.min(targetLeft, containerRect.width - floatingTools.offsetWidth));
        targetTop = Math.max(0, Math.min(targetTop, containerRect.height - floatingTools.offsetHeight));

        floatingTools.style.left = `${targetLeft}px`;
        floatingTools.style.top = `${targetTop}px`;
        floatingTools.style.display = 'flex';
      } else if (floatingTools) {
        floatingTools.style.display = 'none';
      }
    }

    // --- Mouse Event Handlers for Main Canvas (Bar Interaction) ---
    canvas.addEventListener('mousedown', e => {
      if (currentMode !== 'select') return;
      const r = canvas.getBoundingClientRect();
      const mx = e.clientX - r.left;
      const my = e.clientY - r.top;

      if (barPlacementMode) {
        // Place the bar at the clicked location
        barUndoStack.push(JSON.parse(JSON.stringify({ bars: getSerializableBarsState() })));
        barRedoStack = [];

        const bar = {
          widthRatio: 4,    // Default width of 4 units
          heightRatio: 1,   // Default height of 1 unit
          xRatio: Math.round(mx / gridSize), // Snap to grid unit
          yRatio: Math.round(my / gridSize), // Snap to grid unit
          color: barColorToPlace,
          arrow: false,
          dashed: barDashedToPlace,
          split: 0,
          labels: {}
        };
        bars.push(bar);
        selectedBar = bar; // Select the newly placed bar
        drawAll();
        positionFloatingBarTools(); // Position floating tools for the new bar
        barPlacementMode = false; // Exit placement mode
        canvas.style.cursor = 'default'; // Reset cursor
        return; // Prevent further processing for this click
      }

      // Check for resize handle interaction
      for (let bar of bars.slice().reverse()) { // Iterate in reverse to select top-most bar
        const bx = bar.xRatio * gridSize;
        const by = bar.yRatio * gridSize;
        const bw = bar.widthRatio * gridSize;
        const bh = bar.heightRatio * gridSize;

        if (mx >= bx + bw - 10 && mx <= bx + bw + 10 && my >= by + bh / 2 - 10 && my <= by + bh / 2 + 10) {
          selectedBar = bar;
          isResizing = true;
          positionFloatingBarTools(); // Position floating tools
          barUndoStack.push(JSON.parse(JSON.stringify({ bars: getSerializableBarsState() })));
          barRedoStack = [];
          drawAll(); // Redraw to show selection outline
          return;
        }
      }

      // Check for bar dragging interaction
      for (let bar of bars.slice().reverse()) {
        const bx = bar.xRatio * gridSize;
        const by = bar.yRatio * gridSize;
        const bw = bar.widthRatio * gridSize;
        const bh = bar.heightRatio * gridSize;

        if (mx >= bx && mx <= bx + bw && my >= by && my <= by + bh) {
          selectedBar = bar;
          dragOffsetX = mx - bx;
          dragOffsetY = my - by;
          isDragging = true;
          positionFloatingBarTools(); // Position floating tools
          barUndoStack.push(JSON.parse(JSON.stringify({ bars: getSerializableBarsState() })));
          barRedoStack = [];
          drawAll(); // Redraw to show selection outline
          return;
        }
      }
      // If no bar or handle is selected, deselect any previously selected bar
      selectedBar = null;
      positionFloatingBarTools(); // Hide floating tools
      drawAll(); // Redraw to remove selection outline
    });

    canvas.addEventListener('mousemove', e => {
      if (!selectedBar || (!isResizing && !isDragging) || currentMode !== 'select') return;
      const r = canvas.getBoundingClientRect();
      const mx = e.clientX - r.left;
      const my = e.clientY - r.top;
      
      const snapUnit = gridSize / 10; // Finer snapping for movement/resize

      if (isResizing) {
        selectedBar.widthRatio = Math.max(1, Math.round((mx - selectedBar.xRatio * gridSize) / snapUnit) * snapUnit / gridSize);
        updateLabels();
        drawAll();
        positionFloatingBarTools(); // Reposition floating tools
        return;
      }

      if (isDragging) {
        selectedBar.xRatio = Math.round((mx - dragOffsetX) / snapUnit) * snapUnit / gridSize;
        selectedBar.yRatio = Math.round((my - dragOffsetY) / gridSize);
        updateLabels();
        drawAll();
        positionFloatingBarTools(); // Reposition floating tools
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDragging = false;
      isResizing = false;
    });

    // --- Mouse Event Handlers for Drawing Canvas ---
    drawingCanvas.addEventListener('mousedown', e => {
      if (currentMode !== 'draw') return;
      undoStack.push(drawingCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height)); // Save current state for undo
      redoStack = []; // Clear redo stack
      isDrawing = true;
      const r = drawingCanvas.getBoundingClientRect();
      drawingCtx.beginPath();
      drawingCtx.strokeStyle = penColor;
      drawingCtx.lineWidth = penSize;
      drawingCtx.lineCap = 'round'; // Added for smoother lines
      drawingCtx.lineJoin = 'round'; // Added for smoother lines
      drawingCtx.moveTo(e.clientX - r.left, e.clientY - r.top);
    });

    drawingCanvas.addEventListener('mousemove', e => {
      if (!isDrawing) return;
      const r = drawingCanvas.getBoundingClientRect();
      drawingCtx.lineTo(e.clientX - r.left, e.clientY - r.top);
      drawingCtx.stroke();
    });

    drawingCanvas.addEventListener('mouseup', () => {
      isDrawing = false;
      drawingImage = drawingCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height); // Update drawingImage
    });

    // --- Keyboard Event Handler ---
    document.addEventListener('keydown', (e) => {
      // Check if focus is on an input or textarea element
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return; // Do not trigger shortcuts if typing
      }

      const key = e.code;
      const ctrlKey = e.ctrlKey || e.metaKey; // Compatible with Mac's Command key
      const shiftKey = e.shiftKey;

      for (const shortcutKey in KEYBOARD_SHORTCUTS) {
        const shortcut = KEYBOARD_SHORTCUTS[shortcutKey];
        // Check if the pressed key and modifier keys match the shortcut
        if (key === shortcutKey && 
            (shortcut.ctrlKey === undefined || shortcut.ctrlKey === ctrlKey) && 
            (shortcut.shiftKey === undefined || shortcut.shiftKey === shiftKey)) {
          
          e.preventDefault(); // Prevent default browser actions (e.g., Ctrl+S saves the page)
          
          if (shortcut.func) {
            // Call the function with its arguments, if any
            shortcut.func(...(shortcut.args || []));
          }
          break; // Stop after the first matching shortcut is found
        }
      }
    });
  </script>
</body>
</html>
